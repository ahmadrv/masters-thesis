\chapter{نتیجه‌گیری}
نتایج آزمایش‌های انجام‌شده با استفاده از ابزار توسعه داده شده در نمودارها و جدول‌های متفاوت گردآوری شده‌اند. دسته‌بندی این نتایج در حالت‌های متفاوت و با دیدگاه‌های مختلف در بخش‌های این فصل تدوین‌شده تا خواننده بتواند بر اساس آن‌ها قضاوت منصفانه‌تری را داشته باشد.

\section{روند آزمایش‌ها}
همان‌طور که در قبل هم اشاره شد، انجام آزمایش‌ها روندی الگوپذیر بوده است. برای بهبود و تسریع در این روند، از ابزار اشاره شده در طول آزمایش‌ها بهره‌برداری شده است.

آزمایش‌ها به این صورت بوده که برای هر پلتفرم، پیاده‌سازی الگوریتم‌های محک، به صورتی که این پیاده‌سازی‌ها از یک ساختار الگوریتمی و نرم‌افزاری یکسان پیروی کنند، انجام شده است. این که ساختار در پیاده‌سازی‌های مختلف حفظ شود به این معنا است که مثلاً اگر در پیاده‌سازی یک الگوریتم در یک پلتفرم نیاز است از حلقه استفاده شود، در دیگری هم به همین صورت باشد به‌طوری‌که در هر دو پلتفرم پیاده‌سازی‌ها از پیچیدگی محاسباتی یکسانی برخوردار باشند چرا که هدف محک منصفانهٔ آن‌ها است. برای این امر، وقت زیادی از پژوهش صرف شد چرا که پیاده‌سازی‌های موجود در هر پلتفرم با دیگری متفاوت است و عملاً برای محکی که جانب انصاف را رعایت کند، نمی‌تواند مورداستفاده قرار بگیرد. در نتیجه در پیاده‌سازی‌های موجود باید تجدید نظر انجام می‌شد.

همان‌طور که اشاره شد، هدف  پژوهش ما کاربرانی بوده‌اند که از رایانه‌های شخصی استفاده می‌کنند. به همین منظور، رایانهٔ استفاده شده در طول این آزمایش‌ها، رایانهٔ شخصی موجود در آزمایشگاه دانشکده با پردازندهٔ 
\lr{Intel(R) Core(TM) i7-3770 CPU @ 3.40GHz}
با ۸ هستهٔ پردازشی، حافظهٔ ۱۶ گیگابایتی، بدون پردازندهٔ گرافیکی و سیستم‌عامل لینوکس، توزیع اوبونتو با نسخهٔ هستهٔ
\lr{5.15.0-119-generic}
بوده است.


برای آزمایش هر شبیه‌ساز توسط ابزار توسعه داده شده، زمان اجرا و میزان حافظهٔ مصرفی با افزایش تعداد کیوبیت اندازه‌گیری و در پایگاه‌داده ذخیره شده است. از آن‌جایی که شبیه‌سازها در دو پلتفرم Qiskit و Cirq قرار دارند، در ادامه، آن‌ها را به تفکیک پلتفرم بررسی می‌کنیم. شکل \ref{fig:2} بیانگر نحوهٔ ارتباط پلتفرم‌ها، بک‌اند\LTRfootnote{Back-End}ها و شبیه‌سازهاست.
 
\begin{figure}
 	\centering
 	\captionsetup{justification=centering,margin=2cm}
 	\includegraphics[scale=1]{images/backend_simulator_relation.pdf}
 	\caption{
 	نمودار روابط پلتفرم‌ها و اجزای آن‌ها (قسمت‌های خاکستری در پژوهش ما مورد بحث و بررسی نبوده‌اند.)
 	}
 	\label{fig:2}
 \end{figure}
 
\subsection{Qiskit}
 این پلتفرم توسط گروه تحقیقاتی IBM 
 \cite{javadi-abhari_quantum_2024}
 معرفی شده است که شامل چندین شبیه‌ساز با رویکردهای متفاوت شامل آن‌چه که در بخش
 \nameref{sec:simulators}
 گفته شده است. این پلتفرم علاوه بر شبیه‌ساز قابلیت‌هایی نظیر بهینه‌سازی و ترجمهٔ الگوریتم‌ها به زبان اسمبلی کوانتومی را نیز دارا است. علاوه‌برآن قابلیت اتصال به رایانه‌های واقعی کوانتومی ابری را نیز فراهم کرده است.
 
 هر پلتفرم برای جداسازی شبیه‌سازها باتوجه‌به رویکرد آن‌ها از بک‌اندهای متفاوت که همان لایه‌ای نرم‌افزاری باهدف چارچوب‌بندی به هر رویکرد شبیه‌سازی هستند، تشکیل شده است. در ادامه، شبیه‌سازها را به تفکیک بک‌اند، بررسی خواهیم کرد.
 
\subsubsection{Aer}
این بک‌اند شامل چهار شبیه‌ساز
\lr{AerSimulator}، \lr{QasmSimulator}، \lr{StatevectorSimulator} و \lr{UnitarySimulator}
است
\cite{javadi-abhari_quantum_2024}.
در پژوهش ما فقط به بررسی دو مورد اول پرداخته شده است.

\paragraph{:AerSimulator}
این شبیه‌ساز از چندین روش شبیه‌سازی و گزینه‌های قابل‌تنظیم برای هر روش شبیه‌سازی پشتیبانی می‌کند
\cite{noauthor_aersimulator_nodate}.
در محک این شبیه‌ساز، ابتدا الگوریتم‌های توضیح داده شده در بخش
\nameref{sec:algorithm_selection}
را اجرا و زمان اجرا و میزان حافظهٔ مصرفی آن را به تحریر نمودار درآورده‌ایم. نتیجهٔ حاصل شده در شکل‌های \ref{fig:3} و \ref{fig:4} نشانگر رفتار این شبیه‌ساز در اجرای الگوریتم‌های مختلف است.

از آن‌جایی که نتایج مربوط به الگوریتم Shor رفتار متفاوتی نسبت به دیگر الگوریتم‌ها داشته است، خروجی‌های مربوط به این الگوریتم در قالب جدول گزارش خواهد شد. این تفاوت در آن‌جایی است که برخلاف دیگر الگوریتم‌ها، داده‌های ورودی این الگوریتم محدودتر هستند و افزایش تعداد کیوبیت‌ها با افزایش عدد مرکب از دو عدد اول صورت می‌پذیرد. برای مثال در جدول \ref{tab:1} برای تجزیه‌ی عدد مرکب ۷۷ که از حاصل ضرب اعداد اول ۷ و ۱۱ بدست ‌می‌آید، الگوریتم Shor به ۲۴ کیوبیت احتیاج دارد تا بتواند این عدد را به عوامل اول آن تجزیه کند. به دلیل هم‌پوشانی که بین فاکتور‌های اول اعداد مرکب وجود دارد، نمی‌توان تعداد کیوبیت‌ها را یکی‌یکی افزایش داد و به همین دلیل زمان اجرا و حافظه‌ی مصرفی در قالب جداول نظیر جدول \ref{tab:1} گزارش شده است.

\begin{table}[h!]
	\centering
	\begin{LTR}
	\begin{tabular}{ |c|c|c|c| } 
		\hline
		\rl{عدد مرکب} & \rl{تعداد کیوبیت} & \rl{میانگین زمان اجرا (ثانیه)}  & \rl{میانگین حافظهٔ مصرفی (مگابایت)} \\
		\hline
		15 & 15 & 1.633536 & 121.723568 \\
		35 & 21 & 2.037188 & 122.529990 \\
		77 & 24 & 2.056493 & 125.207344 \\
		143 & 27 & 13.982873 & 129.990885 \\
		437 & 30 & N/A & N/A \\
		\hline
	\end{tabular}
	\end{LTR}
	\caption{
		جدول اطلاعات مربوط به اجرای الگوریتم Shor با
		\lr{Aer Simulator}
	}
	\label{tab:1}
\end{table}


\begin{figure}
	\centering
	\captionsetup{justification=centering}
	\input{images/Qiskit_aer_aer_simulator_runtime.tex}
	\caption{
		نمودار زمان اجرا بر حسب تعداد کیوبیت الگوریتم‌های مختلف در
		\lr{Aer Simulator}
		}
	\label{fig:3}
	\vspace{2cm}
	\captionsetup{justification=centering}
	\input{images/Qiskit_aer_aer_simulator_memory_usage.tex}
	\caption{
		نمودار مصرف حافظه بر حسب تعداد کیوبیت الگوریتم‌های مختلف
		\lr{Aer Simulator}
		}
	\label{fig:4}
\end{figure}

 از آن‌جایی که در محدودیت‌های این شبیه‌ساز تعداد ۳۲ کیوبیت ذکر شده همان‌طور که مشاهده می‌شود این شبیه‌ساز، در این محدوده، در اجرای همهٔ الگوریتم‌ها همان‌طور که انتظار می‌رود رفتار کرده است. دلیل این که محک با الگوریتمی نظیر Simon فقط تا ۱۶ کیوبیت ادامه پیدا کرده است این است که این الگوریتم برای حل مسئله به دوبرابر تعداد کیوبیت ورودی نیاز دارد. دیگر الگوریتم‌ها نظیر
 \lr{Grover}
 در تعداد کیوبیت کمتر رفتاری خطی و با افزایش تعداد کیوبیت رفتاری نمایی به خود می‌گیرند، طبق آن‌چه که در 
 \cite{jamadagni_benchmarking_2024}
 هم حدس زده شده است، امکان بهینه‌سازی غیر جامع این شبیه‌سازها به‌طوری‌که برای تعداد کیوبیت کمتر، بهینه شده باشند، وجود دارد.
  
  
\paragraph{:QasmSimulator}
این شبیه‌ساز هم از چندین روش شبیه‌سازی و اضافه‌کردن نویز به محاسبات پشتیبانی می‌کند. مانند قبل، اجرای الگوریتم‌ها با این شبیه‌ساز، در شکل‌ \ref{fig:5} برای زمان اجرا و در شکل \ref{fig:6} برای مصرف حافظه، آورده شده است.

\begin{figure}
	\centering
	\captionsetup{justification=centering}
	\input{images/Qiskit_aer_qasm_simulator_runtime.tex}
	\caption{
		نمودار زمان اجرا بر حسب تعداد کیوبیت الگوریتم‌های مختلف در 
		\lr{Qasm Simulator}
		}
	\label{fig:5}
	\vspace{2cm}
	\captionsetup{justification=centering}
	\input{images/Qiskit_aer_qasm_simulator_memory_usage.tex}
	\caption{
		نمودار مصرف حافظه بر حسب تعداد کیوبیت الگوریتم‌های مختلف در
		\lr{Qasm Simulator}
		}
	\label{fig:6}
\end{figure}

از آن‌جایی که این دو شبیه‌ساز در یک بک‌اند توسعه داده شده‌اند، تفاوت چندانی در عملکرد آن‌ها مشاهده نمی‌شود و رفتار مشابهی را در مواجهه با الگوریتم‌های مختلف دارند که این رفتار موردانتظار از شبیه‌سازهای مدارهای کوانتومی است.

به صورت مجزا، عملکرد این شبیه‌ساز در اجرای الگوریتم Shor در جدول \ref{tab:2} گزارش شده است.
\begin{table}[h!]
	\centering
	\begin{LTR}
		\begin{tabular}{ |c|c|c|c| } 
			\hline
			\rl{عدد مرکب} & \rl{تعداد کیوبیت} & \rl{میانگین زمان اجرا (ثانیه)}  & \rl{میانگین حافظهٔ مصرفی (مگابایت)} \\
			\hline
			15 & 15 & 1.770852 & 121.732682 \\
			35 & 21 & 3.714265 & 123.226562 \\
			77 & 24 & 2.542166 & 125.411875 \\
			143 & 27 & 14.051529 & 130.393229 \\
			437 & 30 & N/A & N/A \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{
		جدول اطلاعات مربوط به اجرای الگوریتم Shor با
		\lr{Qasm Simulator}
	}
	\label{tab:2}
\end{table}
 
\subsubsection{DDSIM}
این بک‌اند چهارچوبی برای شبیه‌سازها تعیین کرده است که از یک روش مبتنی بر گراف، به‌ویژه نمودارهای تصمیم‌گیری، برای شبیه‌سازی کارآمد مدارهای کوانتومی استفاده می‌کند و به‌جای ذخیره بردارها و ماتریس‌های بزرگی که به‌صورت نمایی رشد می‌کنند، از این نمودارها برای ثبت تکرارهای موجود در محاسبات بهره می‌برد. در واقع به نحوی از برنامه‌نویسی پویا برای بهبود کارایی شبیه‌سازی استفاده می‌کند و به‌این‌ترتیب استفاده از حافظه را به میزان قابل‌توجهی کاهش می‌دهد. عملیات کوانتومی از طریق ضرب ماتریس‌ها و بردارها در این قالب به‌صورت بازگشتی انجام می‌شوند بدون این که نیاز باشد کل آن‌ها پردازش شوند. اندازه‌گیری نیز به همین شکل انجام می‌شود و تغییرات حالت به طور کارآمد در نمودارها نمایش داده می‌شود. این روش باعث می‌شود که این نوع از شبیه‌سازها در مقایسه با شبیه‌سازهای دیگر، عملکرد بهتری داشته باشند و بتوانند تعداد بیش‌تری کیوبیت را مدیریت کنند و زمان و حافظهٔ محاسباتی کمتری مصرف کنند 
\cite{zulehner_advanced_2019}.
\paragraph{:QasmSimulator}
این شبیه‌ساز از روش Schrödinger استفاده می‌کند که بر اساس نمودارهای تصمیم‌گیری به‌عنوان یک ساختمان داده، طراحی شده و می‌توان از آن برای به‌دست‌آوردن بردار حالت کامل مدار کوانتومی «شبیه‌سازی قوی» 
\cite{zulehner_advanced_2019}
و یا نمونه‌گیری از توزیع خروجی یک مدار کوانتومی «شبیه‌سازی ضعیف» 
\cite{hillmich_just_2020}
بهره برد. برای این منظور، شبیه‌ساز با نمایش نمودار تصمیم‌گیری از حالت اولیه آغاز می‌شود و سپس در هر مرحله، گیت‌های مدار را یکی‌یکی اعمال می‌کند. نمایش نمودار تصمیم‌گیری از بردار حالت در هر مرحله به‌روزرسانی می‌شود. این شبیه‌ساز قادر است مدارهای کوانتومی تقریباً دلخواه، از جمله مدارهایی با اندازه‌گیری‌ها و بازتنظیم‌های میانی را مدیریت کند. برای مدارهایی که شامل عملیات غیر واحدی (به‌جز اندازه‌گیری‌ها در انتهای مدار) نیستند، شبیه‌سازی فقط یک‌بار انجام می‌شود. در این حالت، تعداد نمونه‌های درخواستی به طور متعاقب از نمودار تصمیم‌گیری نهایی گرفته می‌شود که منجر به زمان اجرای سریع شبیه‌سازی می‌گردد.

شایان‌ذکر است که این شبیه‌ساز با شبیه‌سازی که در قسمت قبل توضیح داده شده است، متفاوت است. با این که هر دو از روش Schrödinger برای شبیه‌سازی بهره گرفته‌اند؛ اما ساختمان داده‌ای که در شبیه‌ساز دوم با بک‌اند DDSIM توسعه‌یافته به طور کامل با شبیه‌ساز با بک‌اند Aer متفاوت است.

\begin{figure}
	\centering
	\captionsetup{justification=centering}
	\input{images/Qiskit_ddsim_qasm_simulator_runtime.tex}
	\caption{
		نمودار زمان اجرا بر حسب تعداد کیوبیت الگوریتم‌های مختلف در
		\lr{DDSIM Qasm Simulator}
		}
	\label{fig:7}
	\vspace{2cm}
	\captionsetup{justification=centering}
	\input{images/Qiskit_ddsim_qasm_simulator_memory_usage.tex}
	\caption{
		نمودار مصرف حافظه بر حسب تعداد کیوبیت الگوریتم‌های مختلف در
		\lr{DDSIM Qasm Simulator}
		}
	\label{fig:8}
\end{figure}

شکل‌های \ref{fig:7} و \ref{fig:8} رفتار این شبیه‌ساز را نسبت به الگوریتم‌های مختلف نشان می‌دهد که به‌طورکلی در مقایسه با شبیه‌ساز Aer در زمان اجرا و حافظهٔ کمتری شبیه‌سازی‌ها را انجام داده است که این خود نقطه‌ی قوت این شبیه‌ساز را نشان می‌دهد و این بهبود برای محققانی که قصد اجرای شبیه‌سازها بر روی رایانه‌های شخصی را دارند بسیار مؤثر خواهد بود. همان‌طور که در بخش‌های قبل گفته شد، پیاده‌سازی الگوریتم
\lr{Simon}،
به دلیل عدم وجود ویژگی ذخیرهٔ نتایج اجرای الگوریتم‌ها، در این بک‌اند انجام نشده است و به همین دلیل در نمودارهای ذکر شده، اطلاعاتی مربوط به الگوریتم Simon وجود ندارد.

با تفاوت‌‌های ذکرشده در ساختار الگوریتم Shor و تفاوت‌های آن با دیگر محک‌ها، عملکرد این شبیه‌ساز در اجرای این الگوریتم به صورت مجزا در جدول \ref{tab:3} گزارش شده است. رفتار این شبیه‌ساز در اجرای این الگوریتم با افزایش از ۲۱ کیوبیت به ۲۴ کیوبیت، غیرقابل انتظار بوده است چرا که انتظار بر این است با افزایش تعداد کیوبیت زمان اجرا و میزان مصرف حافظه هم افزایش یابد. در توجیه این رفتار، از آن‌جایی که الگوریتم Shor در مراحل خود به صورت احتمالی به پاسخ می‌رسد، رسیدن به پاسخ در زمان محدودشده در آزمایش‌ها (۳۶۰۰ ثانیه برای هر اجرا) امکان‌پذیر نبوده است. این در حالی است که هر اجرا به بیش از ۵ بار تکرار انجام شده است. در نتیجه این کاهش زمان در قبال نرسیدن به پاسخ نهایی بوده است.
\begin{table}[h!]
	\centering
	\begin{LTR}
		\begin{tabular}{ |c|c|c|c| } 
			\hline
			\rl{عدد مرکب} & \rl{تعداد کیوبیت} & \rl{میانگین زمان اجرا (ثانیه)}  & \rl{میانگین حافظهٔ مصرفی (مگابایت)} \\
			\hline
			15 & 15 & 1.643833 & 124.590885 \\
			35 & 21 & 3.008140 & 131.823495 \\
			77 & 24 & 1.883989 & 128.149063 \\
			143 & 27 & 6.765308 & 147.167188 \\
			437 & 30 & N/A & N/A \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{
		جدول اطلاعات مربوط به اجرای الگوریتم Shor با
		\lr{DDSIM Qasm Simulator}
	}
	\label{tab:3}
\end{table}

\paragraph{\lr{:Hybrid QasmSimulator}}
این مدل شبیه‌ساز از رویکرد ترکیبی
\lr{Schrödinger-Feynman}
استفاده می‌کند به‌طوری‌که از تمام حافظه و واحدهای پردازشی موجود برای شبیه‌سازی کارآمد مدارهای کوانتومی بهره ببرد. در شبیه‌سازی‌هایی که به سبک Schrödinger هستند با محدودیت‌های حافظه مواجه می‌شوند و یا در شبیه‌سازی‌های به سبک Feynman مدت‌زمان بسیار زیادی نیاز دارند، این شبیه‌ساز سعی می‌کند با ایجاد یک مصالحه بین الزامات حافظه و زمان اجرا بهترین شبیه‌سازی ممکن، وابسته به مدار کوانتومی ورودی را ارائه دهد
 \cite{noauthor_hybrid_nodate}.
 
 شکل‌های \ref{fig:9} و \ref{fig:10} رفتار این شبیه‌ساز را نسبت به الگوریتم‌های مختلف نشان می‌دهد. از آن‌جایی که این مدل شبیه‌ساز در مراحل اولیهٔ توسعهٔ خود قرار دارد، این احتمال وجود دارد که انتخاب بین استفاده از رویکردهای یاد شده، باعث چنین ناهمواری‌هایی در نمودار زمان اجرا و حافظه شود. در کل، بدون در نظر گرفتن وقت صرف شده برای توسعهٔ شبیه‌سازهای مختلف، این شبیه‌ساز عملکرد خوبی نسبت به شبیه‌سازهایی که تاکنون شرح داده شده‌اند، نداشته است.

\begin{figure}
	\centering
	\captionsetup{justification=centering}
	\input{images/Qiskit_ddsim_hybrid_qasm_simulator_runtime.tex}
	\caption{
		نمودار زمان اجرا بر حسب تعداد کیوبیت الگوریتم‌های مختلف در
		\lr{DDSIM Hybrid Qasm Simulator}
	}
	\label{fig:9}
	\vspace{2cm}
	\captionsetup{justification=centering}
	\input{images/Qiskit_ddsim_hybrid_qasm_simulator_memory_usage.tex}
	\caption{
		نمودار مصرف حافظه بر حسب تعداد کیوبیت الگوریتم‌های مختلف در
		\lr{DDSIM Hybrid Qasm Simulator}
	}
	\label{fig:10}
\end{figure}

همان مشکلی که برای پیاده‌سازی الگوریتم Simon بیان شد، باعث عدم پیاده‌سازی الگوریتم Shor در این شبیه‌ساز گردیده است.

\subsection{Cirq}
\lr{Cirq}
یک پلتفرم محاسبات کوانتومی است که برای طراحی، بهینه‌سازی و اجرای مدارهای کوانتومی بر روی رایانه‌های کوانتومی و شبیه‌سازهای کوانتومی استفاده می‌شود. Cirq قابلیت اجرا بر روی پردازنده‌های کوانتومی مانند
\lr{Alpine}، \lr{Pasqal}، \lr{Rigetti} و \lr{IonQ}
را نیز داراست. این پلتفرم دارای شبیه‌سازهای داخلی برای آزمایش مدارهای کوچک است و از شبیه‌سازهایی با عملکرد بالا مانند Qulacs و quimb نیز پشتیبانی می‌کند. Cirq همچنین با پلتفرم‌های نرم‌افزاری دیگر مانند
\lr{QC Ware Forge}، \lr{Xanadu Pennylane} و \lr{Zapata Orquestra}
می‌تواند ارتباط برقرار کند و راه‌حل‌های پیچیده‌تری را پوشش دهد. Cirq بخشی از اکوسیستم متن‌باز
\lr{Google Quantum AI}
 است که شامل
\lr{ReCirq}، \lr{OpenFermion}
و
\lr{TensorFlow Quantum}
می‌شود.
\subsubsection{Cirq}
همان‌طور که اشاره شد پلتفرم Cirq از شبیه‌سازهای داخلی برای مدارهای کوچک‌تر را داراست. دو نوع اصلی شبیه‌سازی که Cirq پشتیبانی می‌کند، شبیه‌سازی حالت خالص و شبیه‌سازی حالت مخلوط هستند. شبیه‌سازهای حالت خالص توسط cirq.Simulator و شبیه‌سازهای حالت مخلوط توسط cirq.DensityMatrixSimulator پشتیبانی می‌شوند که در پژوهش ما فقط به شبیه‌سازی‌های حالت خالص پرداخته شده است چرا که شبیه‌سازی‌های حالت مخلوط به‌طورکلی از ماهیت متفاوتی برخوردارند. در واقع شبیه‌ساز حالت خالص و شبیه‌ساز حالت مخلوط به این واقعیت اشاره دارند که این شبیه‌سازی‌ها برای مدارهای کوانتومی هستند که در طول شبیه‌سازی اعم از اعمال انواع گیت‌ها، اندازه‌گیری‌ها و نویزها که حاصل را در حالت خالص (یک حالت کوانتومی منفرد) یا حالت مخلوط (ترکیبی از حالت‌های کوانتومی مختلف) حفظ می‌کنند. شبیه‌ساز حالت خالص از تکامل‌های نویزی پشتیبانی می‌کند، به شرطی که خلوص حالت را حفظ کنند.

به‌طورکلی، شبیه‌سازی حالت خالص، روند شبیه‌سازی و نتیجهٔ آن را در یک حالت کوانتومی حفظ می‌کند، چه باوجود نویز و چه بدون آن، درصورتی‌که شبیه‌سازی حالت مخلوط، روند شبیه‌سازی را در ترکیبی از حالت‌های کوانتومی ارائه می‌دهد.

برخی از شبیه‌سازهای دیگر با عملکرد بهتر نسبت به شبیه‌ساز قیدشده نیز یک رابط به Cirq ارائه می‌دهند. این شبیه‌سازها، به‌ویژه هنگام کار با مدارهای بزرگ‌تر، اغلب می‌توانند نتایج را سریع‌تر از شبیه‌سازهای داخلی Cirq ارائه دهند. Qsim نمونه‌ای از آن‌ها است
\cite{noauthor_simulation_nodate}.
\paragraph{:Pure}
همان‌طور که گفته شد، این شبیه‌ساز داخلی پلتفرم Cirq برای مدارهای کوچک‌تر است که یک شبیه‌ساز بردار حالت با روش نمایش ماتریس پراکنده است و از کتابخانهٔ NumPy برای انجام محاسبات استفاده می‌کند.

شکل‌های \ref{fig:11} و \ref{fig:12} رفتار این شبیه‌ساز را نسبت به الگوریتم‌های مختلف نشان می‌دهد. نسبت به شبیه‌سازهایی که تاکنون بررسی شده است، عملکرد بهتری را چه در زمان اجرا و چه در مصرف حافظه نشان می‌دهد.

\begin{figure}

	\centering
	\captionsetup{justification=centering}
	\input{images/Cirq_cirq_pure_runtime.tex}
	\caption{
		نمودار زمان اجرا بر حسب تعداد کیوبیت الگوریتم‌های مختلف در
		\lr{Cirq Pure}
	}
	\label{fig:11}
	\vspace{2cm}
	\captionsetup{justification=centering}
	\input{images/Cirq_cirq_pure_memory_usage.tex}
	\caption{
		نمودار مصرف حافظه بر حسب تعداد کیوبیت الگوریتم‌های مختلف در
		\lr{Cirq Pure}
	}
	\label{fig:12}
\end{figure}

عملکرد این شبیه‌ساز در اجرای الگوریتم Shor در جدول \ref{tab:4} گزارش شده است.
\begin{table}[h!]
	\centering
	\begin{LTR}
		\begin{tabular}{ |c|c|c|c| } 
			\hline
			\rl{عدد مرکب} & \rl{تعداد کیوبیت} & \rl{میانگین زمان اجرا (ثانیه)}  & \rl{میانگین حافظهٔ مصرفی (مگابایت)} \\
			\hline
			15 & 15 & 3.893985 & 156.183073 \\
			35 & 21 & 5.212129 & 156.684462 \\
			77 & 24 & 5.447729 & 157.431234 \\
			143 & 27 & 8.189291 & 158.885785 \\
			437 & 30 & N/A & N/A \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{
		جدول اطلاعات مربوط به اجرای الگوریتم Shor با
		\lr{Cirq Simulator}
	}
	\label{tab:4}
\end{table}

\paragraph{:Mixed}
در تعریف مقایسه‌ای حالت‌های کوانتومی، یک حالت خالص کوانتومی حالتی است که می‌توان آن را با یک بردار حالت منفرد یا به‌صورت مجموعی از حالت‌های پایه توصیف کرد. یک حالت مخلوط کوانتومی، توزیع آماری‌ای از حالت‌های خالص است. در اینجا مهم است که به دو نوع میانگین‌گیری توجه کنیم: یکی میانگین‌گیری کوانتومی روی بردارهای پایهٔ حالت‌های خالص و دیگری میانگین‌گیری آماری روی مجموعه‌ای از حالت‌های خالص که مربوط حالت مخلوط کوانتومی است.

همان‌طور که ذکر شد، از آن‌جایی که شبیه‌سازی حالت‌های مخلوط کوانتومی دارای پیچیدگی بیش‌تری است و بررسی آن‌های نیازمند زمان دوچندان بوده است، از مطالعهٔ آن‌ها در پژوهش ما صرف‌نظر شده است.
\subsubsection{QSim}
یک شبیه‌ساز کامل بردار حالت Schrödinger است. این شبیه‌ساز تمام $2^n$ دامنه‌های بردار حالت را محاسبه می‌کند که $n$ تعداد کیوبیت‌ها است. در واقع، شبیه‌ساز به طور مکرر ضرب‌های ماتریس-بردار را انجام می‌دهد. هر ضرب ماتریس-بردار معادل با اعمال یک گیت است. زمان کل اجرا با $g2^n$ متناسب است، که $g$ تعداد گیت‌های دو کیوبیتی است. برای سرعت‌بخشیدن به شبیه‌سازی از ادغام گیت‌ها، دستورالعمل‌های AVX/FMA برای تبدیل برداری و OpenMP برای چندرشته‌ای کردن فرایند استفاده می‌شود
\cite{smelyanskiy_qhipster_2016}.

رفتار این شبیه‌ساز در شکل‌های \ref{fig:13} و \ref{fig:14} نمایان است. برتری این شبیه‌ساز در شبیه‌سازی تعداد بیش‌تری از کیوبیت‌ها است. برای مثال الگوریتم
\lr{Deutsch-Jozsa}
را هیچ‌کدام از شبیه‌سازهای گفته شده نتوانستند تا ۱۹ کیوبیت شبیه‌سازی کنند.
\begin{figure}
	\centering
	\captionsetup{justification=centering}
	\input{images/Cirq_qsimcirq_QSimSimulator_runtime.tex}
	\caption{
		نمودار زمان اجرا بر حسب تعداد کیوبیت الگوریتم‌های مختلف در
		\lr{QSim Simulator}
	}
	\label{fig:13}
	\vspace{2cm}
	\captionsetup{justification=centering}
	\input{images/Cirq_qsimcirq_QSimSimulator_memory_usage.tex}
	\caption{
		نمودار مصرف حافظه بر حسب تعداد کیوبیت الگوریتم‌های مختلف در
		\lr{QSim Simulator}
	}
	\label{fig:14}
\end{figure}

عملکرد این شبیه‌ساز در اجرای الگوریتم Shor در جدول \ref{tab:5} گزارش شده است. در مقایسه با دیگر شبیه‌سازها، زمان‌ اجرا و حافظه‌ی بیشتری را مصرف کرده است اما این تفاوت جزئی است.
\begin{table}[h!]
	\centering
	\begin{LTR}
		\begin{tabular}{ |c|c|c|c| } 
			\hline
			\rl{عدد مرکب} & \rl{تعداد کیوبیت} & \rl{میانگین زمان اجرا (ثانیه)}  & \rl{میانگین حافظهٔ مصرفی (مگابایت)} \\
			\hline
			15 & 15 & 5.251006 & 158.405469 \\
			35 & 21 & 5.939157 & 158.407118 \\
			77 & 24 & 6.560053 & 158.896998 \\
			143 & 27 & 9.403682 & 160.254830 \\
			437 & 30 & N/A & N/A \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{
		جدول اطلاعات مربوط به اجرای الگوریتم Shor با
		\lr{Qsim Simulator}
	}
	\label{tab:5}
\end{table}

\subsubsection{QSimh}
این یک شبیه‌ساز ترکیبی
\lr{Schrödinger-Feynman}
است که شبکهٔ هندسی چیدمان کیوبیت‌ها را به دو قسمت تقسیم می‌کند که از تجزیهٔ اشمیت برای تجزیهٔ گیت‌های دو کیوبیتی در جداسازی استفاده می‌شود. روش به این صورت است که اگر رتبهٔ اشمیت هر گیت $m$ و تعداد گیت‌ها در جداسازی $k$ باشد، در آن صورت $m^k$ مسیر وجود دارد. برای شبیه‌سازی یک مدار با بهترین نتیجهٔ شبیه‌سازی از لحاظ شباهت با خروجی موردنظر، باید تمام $m^k$ مسیرها شبیه‌سازی شده و نتایج جمع شوند. زمان کل اجرا با
$ (2^{n_1} + 2^{n_2})m^k$
متناسب است، جایی که
$n_1$
و
$n_2$
تعداد کیوبیت‌ها در بخش اول و دوم هستند. مسیرهای شبیه‌سازی‌ شده مستقل از یکدیگر هستند و می‌توانند به‌سادگی موازی‌سازی شوند تا بر روی ابررایانه‌ها یا در مراکز پردازش سریع اجرا شوند. می‌توان شبیه‌سازی‌ها را بادقت کمتر شبیه‌سازی، تنها با جمع‌کردن بر روی یک بخش از تمام مسیرها اجرا کرد.

به‌علاوه، در این شبیه‌ساز، یک روش بررسی دوسطحی برای بهبود عملکرد استفاده می‌شود. فرض کنید $k$ گیت در یک قسمت از قسمت‌های تقسیم‌شده وجود دارد. ما آن‌ها را نیز به سه قسمت تقسیم می‌کنیم. در واقع
$p+r+s=k$،
که در آن $p$ تعداد گیت‌های «پیشوند»، $r$ تعداد گیت‌های «ریشه» و $s$ تعداد گیت‌های «پسوند» است. اولین سطح بررسی پس از اعمال همهٔ گیت‌ها و از جمله گیت‌های پیشوند اجرا می‌شود و دومین سطح بررسی پس از اعمال همه گیت‌ها و گیت‌های ریشه اجرا می‌شود.

در واقع با تقسیم‌بندی‌ این چنینی، به‌جای حل مسئله در ابعاد بزرگ‌تر با تقسیم آن به مسائل کوچک‌تر، مسئله قابل حل خواهد شد
\cite{markov_quantum_2018}.

از آن جایی که پیاده‌سازی الگوریتم‌ها در این شبیه‌ساز متفاوت از شبیه‌سازهای ذکرشده بوده است، محک الگوریتم‌ها روی این شبیه‌ساز صورت نپذیرفته است و تنها به بیان ویژگی‌های آن بسنده شده است.


\section{بحث و نتیجه‌گیری}
با توجه به شکل
\ref{fig:4.1}
مقایسهٔ شبیه‌سازها در بررسی زمان اجرای الگوریتم‌ها واضح‌تر است. به صورت کلی شبیه‌ساز
\lr{QasmSimulator (DDSIM)}
عملکرد بهتری داشته است اما با توجه به ضعف ساختاری و آن چه که در بخش‌های قبل گفته شد، پیاده‌سازی الگوریتم Simon برای آن ممکن نبود در نتیجه عملکرد آن در اجرای این الگوریتم مشخص نیست. شبیه‌ساز
\lr{Qsim}
به صورت کلی عملکرد ضعیف‌تری نسبت به دیگر الگوریتم‌ها داشته است چرا که در اجرای اکثر الگوریتم‌ها زمان اجرای بیش‌تری را صرف کرده است.

در مقایسه‌ی میزان مصرف حافظهٔ نیز شبیه‌ساز
\lr{QasmSimulator (DDSIM)}
بهترین عملکرد را داشته است. رفتار شبیه‌ساز‌ها در مصرف حافظه و زمان اجرا تقریباً یکسان بوده است.

با توجه به شواهد موجود، شبیه‌سازی که با استفاده از نمودارهای تصمیم با اعمال مرحله‌ای گیت‌های موردنظر الگوریتم‌ها عملیات شبیه‌ساز را انجام داده است، بهترین عملکرد را به ثبت رسانده است. با این تفاسیر، می‌توان به این نتیجه رسید که دیگر روش‌های شبیه‌سازی پیچیده‌تر که توسط دیگر پژوهش‌گران مورد بررسی قرار گرفته است لزوماً عملکرد بهتری نداشته‌اند و پیچیدگی بیش‌تر باعث بهبود عملکرد نشده است. دیگر نتیجه‌ای که می‌توان گرفت، با مقایسه با نتایج حاصل‌شده در
\cite{jamadagni_benchmarking_2024}
می‌توان دریافت که برای حل مسئلهٔ شبیه‌سازی کوانتومی، آن چه که در
\cite{xu_herculean_2023}
به عنوان یک مسئلهٔ بسیار دشوار مطرح شده است، افزایش توان محاسباتی تأثیر به نسبت مناسبی نخواهد داشت. برای مثال با دوبرابر کردن توان سخت‌افزاری، زمان اجرای شبیه‌سازها نصف نخواهد شد. تحقیق و توسعه شبیه‌سازهایی نظیر
\lr{QasmSimulator (DDSIM)}،
کمک شایانی به پیشرفت در این حوزه خواهد بود.
\ttodo[color=LimeGreen]{This part should be checked.}
 
\begin{figure}
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/runtime/bernstein_vazirani.tex}
		\label{fig:4.1.1}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/runtime/dj_constant.tex}
		\label{fig:4.1.2}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/runtime/dj_balanced.tex}
		\label{fig:4.1.3}
	\end{subfigure}
	\vspace{1em} % Add vertical space between rows
	
	% Second row of subfigures
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/runtime/grover.tex}
		\label{fig:4.1.4}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/runtime/simon.tex}
		\label{fig:4.1.5}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/runtime/qft.tex}
		\label{fig:4.1.6}
	\end{subfigure}
	
	\captionsetup{justification=centering}
	\caption{
		 نمودار زمان اجرای الگوریتم‌های بررسی‌شده بر روی تمامی شبیه‌سازها.\newline \textit{توضیحات: دلیل عدم مشاهد‌هٔ واضح نمودار بعضی از شبیه‌سازها، هم‌پوشانی و شباهت رفتاری آن‌ها با دیگر شبیه‌سازهاست. محور افقی نشان‌دهندهٔ تعداد کیوبیت است.}
	}
	\label{fig:4.1}
\end{figure}

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/memory_usage/bernstein_vazirani.tex}
		\label{fig:4.2.1}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/memory_usage/dj_constant.tex}
		\label{fig:4.2.2}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/memory_usage/dj_balanced.tex}
		\label{fig:4.2.3}
	\end{subfigure}
	\vspace{1em} % Add vertical space between rows
	
	% Second row of subfigures
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/memory_usage/grover.tex}
		\label{fig:4.2.4}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/memory_usage/simon.tex}
		\label{fig:4.2.5}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\input{images/memory_usage/qft.tex}
		\label{fig:4.2.6}
	\end{subfigure}
	
	\captionsetup{justification=centering}
	\caption{
		نمودار مصرف حافظهٔ اجرای الگوریتم‌های بررسی‌شده بر روی تمامی شبیه‌سازها.\newline \textit{توضیحات: دلیل عدم مشاهد‌هٔ واضح نمودار بعضی از شبیه‌سازها، هم‌پوشانی و شباهت رفتاری آن‌ها با دیگر شبیه‌سازهاست. محور افقی نشان‌دهندهٔ تعداد کیوبیت است.}
	}
	\label{fig:4.2}
\end{figure}

\section{پژوهش‌های آتی}
محک شبیه‌سازها فرایندی زمان‌بر و پیچیده است چرا که هر شبیه‌ساز از روش، زبان
برنامه‌نویسی، تناسب با سخت‌افزار، رویکردهای بهینه‌سازی متفاوت استفاده کرده است. این که بتوان با وجود تمام این تفاوت‌ها یک ابزار و یک چارچوب معین تعیین کرد، هدف نهایی پژوهش‌های نظیر پژوهش ما است. به عنوان پژوهش آتی می‌توان بر روی طراحی دقیق یک مترجم جامع که بتواند فقط با یک بار پیاده‌سازی الگوریتم‌های محک، آن‌ها را به زبان‌های قابل فهم انواع شبیه‌ساز‌ها ترجمه کند، تمرکز کرد. به علاوه، شبیه‌سازهایی که از روش‌ نمودار تصمیم برای شبیه‌سازی بهره برده‌اند،‌ قابلیت نویدبخشی از خود نشان داده‌اند. توسعه‌ و بهبود آن‌ها می‌تواند پژوهش ارزشمندی را به ارمغان آورد.
\ttodo[color=LimeGreen]{This part should be checked.}







