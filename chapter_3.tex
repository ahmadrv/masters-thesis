\chapter{پژوهش‌}
\section{مطالعات پیشین}
بعد از طرح پرسش‌های پژوهش و کسب دانش و آشنایی با ادبیات حوزه، بدیهی است، گام بعدی یافتن مطالعات پیشین و تحقیق دربارهٔ آن‌ها است. همان‌طور که بحث شد، حوزهٔ رایانش کوانتومی، نوظهور و نوپا است. محک شبیه‌سازها نیز به طبع آن در مراحل اولیهٔ خود قرار دارد و مطابق آنچه که انتظار می‌رفت، مطالعات انجام‌شده از نظر کمی غنی نمی‌باشد. با تمام این تفاسیر، تمامی پژوهش‌های مطالعه‌شده، به ترتیب اهمیت و داشتن شباهت با پژوهش ما، در ادامه بررسی و نقد شده‌اند.

\subsection{محک نرم‌افزارهای شبیه‌سازی رایانه‌های کوانتومی\cite{jamadagni_benchmarking_2024}}
در این مقاله، انتخاب الگوریتم‌ها برای محک شبیه‌سازها بر اساس پژوهش \cite{dalzell_quantum_2023} بوده است که برای پژوهش ما نیز سودمند واقع شده است. تحلیل‌های ارائه‌شده در این پژوهش محدود به شبیه‌سازهای بردار حالت است. در پژوهش ما هم به همین‌گونه است؛ اما با بهره‌گیری از \cite{young_simulating_2023}، سعی در آن بوده است که از دسته‌های مختلف شبیه‌سازی برای انجام محک انتخاب شود.

در این پژوهش
\cite{jamadagni_benchmarking_2024}،
انتخاب شبیه‌سازها بر چند اساس استوار است. اول این که آیا می‌توانند قدرت محاسباتی ارائه‌شده توسط سامانه‌های HPC را بهره‌برداری ‌کنند یا خیر. دوم این که آیا به طور فعال نگهداری و توسعه داده می‌شوند یا خیر و سوم این که دسترسی به مستندات مربوطه (مثال‌ها و آموزش‌های مورداستفاده) فراهم شده است یا خیر. درصورتی‌که انتخاب شبیه‌سازهای پژوهش ما بر اساس دسترسی به آن‌ها از لحاظ متن‌باز بودن، رویکرد شبیه‌سازی، امکان استفاده بر روی رایانه‌های شخصی و مانند این پژوهش
\cite{jamadagni_benchmarking_2024}
در دسترس بودن مستندات بوده است.

در این پژوهش
\cite{jamadagni_benchmarking_2024}،
تمرکز اصلی بر محک شبیه‌سازهای سازگار با HPC است. در پژوهش ما، تأکید اصلی بر محک شبیه‌سازهای مدار کوانتومی بهینه‌سازی شده برای رایانه‌های شخصی که توسط کاربران روزمره استفاده می‌شوند، است. بااین‌حال، باید توجه داشت که شبیه‌سازی مدارهایی با بیش از ۳۰ کیوبیت بر روی رایانه شخصی با ۱۶ گیگابایت حافظه، تقریباً غیرممکن است.

تفاوت‌های مجموعهٔ دستورات سطح بالاتر در میان شبیه‌سازها، چالش مهمی را به وجود می‌آورد. هر شبیه‌ساز نیازمند ترجمهٔ منطق الگوریتمی یکسان به مجموعه‌ای متمایز از دستورات و متغیرها است. این فرایند دستی توسط سطح انتزاع ریاضی شبیه‌ساز، محدود شده و زمان‌بر و مستعد خطا است. در نتیجه، خطر ترجمه نادرست دستورات از الگوریتم کوانتومی اصلی وجود دارد. این چالش بین تحقیق ما و این پژوهش
\cite{jamadagni_benchmarking_2024}
مشترک است.

محک ایده‌آل مستلزم تعاریف یکسان در میان شبیه‌سازها و حتی نسخه‌های مختلف یک شبیه‌ساز است که به دلیل تغییرات زیاد که زادهٔ نوپا بودن این حوزه است، چالش‌های زیادی را در پی دارد. این چالش‌ها، در میان تمامی پژوهش‌ها مشترک هستند.

چالش دیگری که از تعارضات در وابستگی‌های شبیه‌سازها به دیگر نرم‌افزارها ناشی می‌شود، زمانی است که شبیه‌سازهای خاص نیازمند نسخه‌های مشخصی از دیگر نرم‌افزارها هستند. نصب هم‌زمان همهٔ شبیه‌سازها زمانی که چندین شبیه‌ساز یک وابستگی مشترک دارند، غیرعملی می‌شود. در این پژوهش
\cite{jamadagni_benchmarking_2024}
از Singularity و ‌Charliecloud به‌عنوان ابزارهایی برای رفع این مشکل، استفاده شده است. بااین‌حال، باتوجه‌به نیازهای کاربردی‌تر و تفاوت پژوهش ما در این که شبیه‌سازهایی که در رایانه‌های شخصی قابل‌اجرا باشند، مدنظر است، ما از ابزارهای دیگری مانند Docker استفاده کرده‌ایم.

به دلیل محدودیت منابع سخت‌افزاری، ما تأثیر استفاده از GPU را ارزیابی نکرده‌ایم درحالی‌که در این پژوهش
\cite{jamadagni_benchmarking_2024}
این تأثیر به طور گسترده بحث‌وبررسی شده است.

یکی از ویژگی‌های مهم توسعه‌یافته در این پژوهش
\cite{jamadagni_benchmarking_2024}،
ترجمهٔ مجموعهٔ دستورات سطح بالای تبدیل‌شده به OpenQASM یک الگوریتم کوانتومی به مجموعه دستورات خاص شبیه‌ساز انتخاب شده است. در تحقیق ما، این ویژگی موردبحث قرار گرفته؛ اما تصمیم به تأخیر در پیاده‌سازی آن برای کارهای آینده گرفته شده است. اگر هدف ما محک کل شبیه‌ساز کوانتومی به‌عنوان یک جزء باشد، باید یک مترجم طراحی شود که قادر به تبدیل اسکریپت‌های OpenQASM به اسکریپت‌های شبیه‌ساز هدف، مانند Cirq یا Qiskit باشد، تقریباً مشابه آن‌چه که در این پژوهش
\cite{jamadagni_benchmarking_2024}
 وجود دارد؛ اما با این تفاوت که این ترجمه به‌جای این که توسط یک انسان مهندسی شود، توسط یک واحد نرم‌افزاری انجام شود.

در این پژوهش
\cite{jamadagni_benchmarking_2024}،
معیارهایی شامل زمان و مصرف حافظه مطرح شده است. مصرف حافظه، استخراج نشده است؛ زیرا استخراج استفادهٔ واقعی از منابع حافظه‌ای در تنظیمات HPC چندهسته‌ای و چندگره‌ای غیرقابل‌انجام یا حداقل بسیار دشوار می‌شود. بااین‌وجود، ما هر دو ویژگی عملکردی ذکر شده را در نظر می‌گیریم. ویژگی‌های دیگر که می‌توان در نظر گرفت شامل سهولت استفاده، مقیاس‌پذیری و همگرایی برای الگوریتم‌های خاص است که در این پژوهش
\cite{jamadagni_benchmarking_2024}
لحاظ نشده است.

سخت‌افزار معرفی شده در این پژوهش
\cite{jamadagni_benchmarking_2024}،
شامل یک خوشهٔ HPC محلی با محدودیت‌هایی نظیر ۲۳ ساعت با محدودیت حافظه ۳۰۰ گیگابایت برای اجرای CPU و ۳۲۰ گیگابایت حافظه برای GPU به‌ازای ۹۰۰ گیگابایت حافظه CPU برای اجراهایی که از دو واحد GPU و CPU بهره می‌برند. در مقابل، سخت‌افزار ما شامل یک رایانه شخصی استاندارد و به نسبت بسیار ضعیف‌تر با ۴ هسته بوده است که قادر به اجرای ۱ ساعت با محدودیت حافظهٔ ۱۶ گیگابایت برای اجرای CPU است. همچنین، سخت‌افزار ما فاقد GPU بوده است.

الگوریتم‌های محک انتخاب شده در این پژوهش
\cite{jamadagni_benchmarking_2024}
شامل دینامیک مدل \lr{XYZ-Heisenberg}، مدارهای کوانتومی تصادفی (RQC) و تبدیل فوریه کوانتومی (QFT) است. در تحقیق ما، الگوریتم‌هایی مانند \lr{Deutsch-Jozsa (DJ)}، \lr{Bernstein-Vaziran (BV)}، QFT و Simon انتخاب شده‌اند چرا که مثال‌های شبیه‌تری به مسائل دنیای واقعی هستند.

همان‌طور که در این پژوهش
\cite{jamadagni_benchmarking_2024}
ذکر شده، انتظار می‌رود که پیاده‌سازی بهینه با افزایش مقیاس ورودی الگوریتم‌ها به‌گونه‌ای باشد که رفتاری متناسب از خود نشان دهد. به طرز شگفت‌انگیزی، این رفتار مورد انتظار تنها برای اعداد نسبتاً بزرگ کیوبیت مشاهده می‌شود. برای تعداد کیوبیت‌های کوچک‌تر، زمان، وابستگی بسیار ضعیف‌تری به اندازهٔ سامانه نشان می‌دهد و حتی در برخی موارد خاص می‌تواند تقریباً مستقل از اندازهٔ سامانه باشد. این پدیده ممکن است به تحلیل داخلی مدار و بهینه‌سازی که توسط برخی شبیه‌سازها انجام می‌شود، نسبت داده شود. در تحقیق ما نیز این پدیده مشاهده شده است.

در پژوهش ما و این پژوهش
\cite{jamadagni_benchmarking_2024}
محدودیت‌هایی در سه دسته شناسایی شده است: طراحی، زمان و حافظه. محدودیت‌های طراحی به محدودیت‌هایی اشاره دارد که توسط تصمیمات طراحی شبیه‌سازها تحمیل می‌شود و توانایی آن را برای پردازش سامانه‌هایی فراتر از اندازه خاص محدود می‌کند. محدودیت‌های زمانی و حافظه به محدودیت‌هایی اشاره دارد که ناشی از محدودیت‌های منابع یا محدودیت‌هایی است که خود محققان برای صورت‌بخشی عملی به آزمایش‌ها اعمال کرده‌اند.

\subsection{بررسی معیارهای عملکرد کاربردی برای محاسبات کوانتومی\cite{lubinski_application-oriented_2023}}
در مقالهٔ مرور شده، یک مجموعه معیارهای متن‌باز برای برنامه‌های کاربردی کوانتومی معرفی شده است. این مجموعه قادر است رایانه‌های کوانتومی واقعی و شبیه‌سازها را با برنامه‌ها و الگوریتم‌های کوچک که شبیه‌سازی آن‌ها به‌صورت کلاسیک به‌صورت نمایی پیچیده نیست، محک بزند. این معیارها بر اساس دو اندازه‌گیری زمان و Fidelity استوار هستند. هر رایانهٔ کوانتومی یا شبیه‌سازی که در زمان کمتر به نتیجه موردنظر برسد، بهتر عمل کرده است. به همین ترتیب، اگر خروجی هر شبیه‌ساز یا رایانه کوانتومی دارای Fidelity بیش‌تری از نتایج باشد، کار بهتری انجام داده است. Fidelity نوعی اندازه‌گیری است که نزدیکی دو توزیع احتمالی را کمی می‌کند. از آن برای اندازه‌گیری فاصلهٔ بین خروجی رایانهٔ کوانتومی یا شبیه‌ساز و خروجی ایده‌آل استفاده می‌شود.

از مزایای این پژوهش
\cite{lubinski_application-oriented_2023}،
دسترسی رایگان به پیاده‌سازی‌ها و ابزارهای محک است. مزیت دیگر، توضیح کامل مسائل و تعاریف ارائه‌شده در متن و ضمیمهٔ مقاله است که در پژوهش ما برای پیاده‌سازی محک‌ها از آن‌ها بهره‌گیری شده است.

از معایب آن توجه بیش‌تر این پژوهش
\cite{lubinski_application-oriented_2023}
به اندازه‌گیری‌های فیزیکی برای بهبود سخت‌افزار کوانتومی است و کمتر به نرم‌افزارها و شبیه‌سازها توجه شده است. این در حالی است که عیب اصلی این تحقیق، عدم تمرکز در محک تعداد بیش‌تری از شبیه‌سازها است. مشکل دیگر ذکر شده در مقاله، روش بسیار ساده و پایه‌ای برای اندازه‌گیری زمان اجرا است که می‌تواند بسیار دقیق‌تر باشد و جنبه‌های مختلف شبیه‌ساز و لایه‌های نرم‌افزاری آن را بررسی کند.

در این پژوهش
\cite{lubinski_application-oriented_2023}،
الگوریتم‌ها برای محک با این محدودیت انتخاب شده‌اند که شبیه‌سازی آن‌ها به‌صورت نمایی هزینه‌بر نباشد که این خود ممکن است باعث گمراهی در روند سنجش و محک شبیه‌سازها شود.

\subsection{ یک مجموعه معیار QASM سطح پایین برای ارزیابی و شبیه‌سازی NISQ\cite{li_qasmbench_2022}}
در این پژوهش
\cite{li_qasmbench_2022}،
مجموعهٔ معیار طراحی شده را به طور خاص برای ارزیابی و شبیه‌سازی محاسبات کوانتومی (QC) در دورهٔ میانی کوانتومی پر از نویز (NISQ) معرفی می‌کند. این مجموعه که QASMBench نامیده می‌شود، بر اساس زبان اسمبلی OpenQASM است و شامل مجموعه‌ای از الگوریتم‌ها و روال‌های کوانتومی از حوزه‌های مختلف مانند شیمی کوانتومی، جبر خطی و یادگیری ماشین است. هدف QASMBench ارائهٔ یک مجموعهٔ معیار استاندارد و آسان برای محک است که می‌تواند برای ارزیابی عملکرد دستگاه‌های \lr{NISQ}، کامپایلرهای کوانتومی و شبیه‌سازها استفاده شود.
QASMBench
یک مجموعه ابزار جامع است که برای ارزیابی قابلیت‌ها و محدودیت‌های سامانه‌های کوانتومی فعلی با تمرکز بر زبان اسمبلی کوانتومی سطح پایین، طراحی شده است. این مجموعه شامل معیارهایی است که نمایانگر عملیات کوانتومی رایج هستند و بر روی چندین سامانه مانند \lr{IBM-Q} ،\lr{Rigetti} و IonQ آزمایش می‌شوند. این مجموعه همچنین چندین معیار از جمله تراکم گیت، طول عمر نگهداری، تراکم اندازه‌گیری و واریانس درهم‌تنیدگی را معرفی می‌کند تا بینش‌های عمیق‌تری از اجرای مدارهای کوانتومی ارائه دهد.

حاصل این پژوهش
\cite{li_qasmbench_2022}،
شامل مجموعه‌ای گسترده از الگوریتم‌های کوانتومی از چندین حوزه است که آن را به ابزاری همه‌کاره برای ارزیابی جنبه‌های مختلف سامانه‌های کوانتومی تبدیل می‌کند. با مبنا قراردادن معیارها بر اساس
\lr{OpenQASM}،
این مجموعه یک رویکرد استاندارد فراهم می‌کند که می‌تواند در پلتفرم‌های مختلف کوانتومی استفاده شود.

با تمامی نقاط قوتی که این پژوهش
\cite{li_qasmbench_2022}
دارد، ماهیت جامع این مجموعه و گنجاندن معیارهای دقیق ممکن است استفاده کامل از قابلیت‌های آن را برای تازه‌کاران در محاسبات کوانتومی دشوار کند. به‌علاوه، عملکرد معیارها می‌تواند به‌شدت به سخت‌افزار مورداستفاده وابسته باشد که ممکن است تعمیم‌پذیری نتایج را در سامانه‌های کوانتومی مختلف محدود کند. درحالی‌که QASMBench طیف گسترده‌ای از اندازه‌های مدار را پوشش می‌دهد، اثربخشی آن ممکن است با افزایش مقیاس و پیچیدگی سامانه‌های کوانتومی آینده محدود شود.

با این که این پژوهش
\cite{li_qasmbench_2022}
به نظر جامع می‌رسد، اما رویکرد آن برای محک شبیه‌سازها با رویکرد پژوهش ما متفاوت است. در این پژوهش
\cite{li_qasmbench_2022}،
آن دسته از لایه‌های نرم‌افزار که کاربر با آن‌ها در تعامل است، واحدهایی نظیر مترجم یا مفسر زبان سطح بالا به زبان سطح پایین، نادیده گرفته می‌شوند. در واقع فقط الگوریتم‌های ترجمه شده به زبان ماشین اجرا شده و در محک‌ها زمان تبدیل الگوریتم‌ها به کدهای ماشین به طور کلی حذف شده است.

\subsection{دیگر پژوهش‌ها}
پژوهش‌های دیگر در این زمینه با رویکردهای متفاوت انجام شده است. در تعدادی از آن‌ها نظیر \cite{li_quapprox_2024}، سعی در آن بوده که الگوریتم‌های خاصی را برای محک انتخاب کنند چرا که جنبهٔ خاصی از شبیه‌سازی برای آن‌ها مطرح بوده است. در تعدادی دیگر نظیر \cite{miessen_benchmarking_2024, barbaresco_bacq_2024}، سخت‌افزارهای خاص مدنظر بوده است. رویکردهای دیگر برای ساده‌سازی مسئله و یا هدف خاصی که به دنبال آن بوده‌اند از جامعیت‌بخشی به محک‌های آزمایش‌شده، خودداری کرده‌اند که این برخلاف رویکردی است که در پژوهش ما مدنظر بوده است.

همان‌طور که مشخص است، با این که فعالیتی که در پژوهش ما انجام شده است با دیگران شباهت‌هایی دارد؛ اما به طور دقیق، محک شبیه‌سازهایی که بر روی رایانه‌های استاندارد شخصی قابل‌اجرا باشند و در عین حال این محک‌ها از الگوریتم‌هایی انتخاب‌شده باشند که به مسائل دنیای واقعی نزدیک‌تر باشند، در هیچ پژوهشی مشاهده نشده است. در واقع تمامی پژوهش‌ها، محک‌ها را روی ابررایانه‌ها و رایانه‌های پردازش سریع بررسی کرده‌اند که تفاوت محسوسی در رویکرد‌ ما و دیگران ایجاد می‌کند.


\section{انتخاب شبیه‌سازها}
همان‌طور که در قبل اشاره شد، شبیه‌سازها مبتنی بر این که از چه روشی برای انجام شبیه‌سازی استفاده می‌کنند را می‌توان دسته‌بندی کرد. باتوجه‌به پژوهش \cite{young_simulating_2023}، سعی شده است برای محک منصفانه‌تر از هر دستهٔ شبیه‌سازها، یک شبیه‌ساز انتخاب شود که هر دسته برای شرکت در محک حداقل یک نماینده داشته باشد. باید به این نکته توجه داشت که بعضی دسته‌ها دارای هیچ شبیه‌ساز پیاده‌سازی شده‌ای نیستند و در بعضی دسته‌ها انجام پیاده‌سازی زمانی فراتر از زمان در اختیار  پژوهش ما نیاز داشته‌اند.

باتوجه‌به توضیحات داده شده و دیگر شرایط مثل عدم دسترسی به نسخهٔ نهایی، عدم وجود راهنماها و سندهای استفاده از شبیه‌سازها که به توسعه‌دهندگان شبیه‌سازها مربوط می‌شود، شبیه‌سازهای زیر برای محک انتخاب شده‌اند:
\begin{itemize}
	\itemsep -1em 
	\item شبیه‌ساز \lr{Aer}، زیرمجموعهٔ سامانهٔ Qiskit
	\item شبیه‌ساز \lr{QASM}، زیرمجموعهٔ سامانهٔ Qiskit
	\item شبیه‌ساز \lr{QASM}، زیرمجموعهٔ سامانهٔ DDSIM
	\item شبیه‌ساز \lr{Hybrid QASM}، زیرمجموعهٔ سامانهٔ DDSIM
	\item شبیه‌ساز \lr{Pure}، زیرمجموعهٔ سامانهٔ Cirq
	\item شبیه‌ساز \lr{QSimCirq}، زیرمجموعهٔ سامانهٔ Cirq
\end{itemize}

همان‌طور که اشاره شد، از آن‌جایی که توسعهٔ این شبیه‌سازها هنوز به بلوغ کامل نرسیده است، استفاده از آن‌ها در پیاده‌سازی تمامی الگوریتم‌ها دشوار و گاهی اوقات غیرممکن است. برای مثال چالشی که در طول پژوهش به آن برخورد کردیم، پیاده‌سازی الگوریتم‌هایی که به ذخیرهٔ اندازه‌گیری‌ها در طول آن نیاز دارند در شبیه‌ساز \lr{Hybrid QASM} (مورد چهارم) انجام نشد. دلیل آن هم عدم توانایی این شبیه‌ساز در ارائهٔ ویژگی یادشده است. اما کار ما در این‌جا پایان نیافت و با مکاتبه‌ای که با توسعه‌دهندگان این شبیه‌ساز انجام شد، قول پیاده‌سازی این ویژگی داده شد. با استناد بر مکاتبه\LTRfootnote{\url{https://github.com/cda-tum/mqt-ddsim/issues/326}}، تا زمان نگارش این نوشته، ویژگی یادشده تکمیل و پیاده‌سازی نشده است.
\section{انتخاب الگوریتم‌های محک}
در این بخش سعی شده است الگوریتم‌هایی برای محک شبیه‌سازها انتخاب شود که از شهرت بیش‌تری برخوردار هستند و در نتیجه کاربرد بیش‌تری نسبت به دیگر الگوریتم‌ها دارند. به‌علاوه، بعضی الگوریتم‌ها نظیر
\lr{Quantum Fourier Transform}
که پایه‌ای برای دیگر الگوریتم‌ها هستند نیز انتخاب شده‌اند. درصورتی‌که شبیه‌سازها در اجرای این الگوریتم‌ها به‌خوبی عمل کنند می‌توان نتیجه گرفت که در حل بسیاری از مسائل دارای عملکرد خوبی هستند.
\label{sec:algorithm_selection}
\subsection{Deutsch-Jozsa}
الگوریتم Deutsch-Jozsa یکی از اولین الگوریتم‌های کوانتومی است که قدرت محاسبات کوانتومی را نسبت به روش‌های کلاسیک نشان می‌دهد. این الگوریتم با استفاده از تعداد ورودی‌های بسیار کمتری نسبت به هر الگوریتم کلاسیک، تعیین می‌کند که آیا یک تابع دودویی داده‌شده مثل $f$، ثابت است (برای همه ورودی‌ها خروجی یکسانی تولید می‌کند) یا متعادل است (برای نیمی از ورودی‌ها خروجی ۰ و برای نیمه دیگر خروجی ۱ تولید می‌کند). در الگوریتم کلاسیک، برای تعیین این که آیا یک تابع ثابت یا متعادل است، ممکن است نیاز باشد، در بدترین حالت، به تابع $2^{n-1} + 1$ بار ورودی بدهیم تا خروجی آن را مشخص کنیم. اما الگوریتم Deutsch-Jozsa این مسئله را تنها با یک‌بار ورودی دادن به Oracle کوانتومی حل می‌کند که این نشان‌دهندهٔ یک کاهش پیچیدگی نمایی است.

\subsubsection{پیاده‌سازی}
الگوریتم Deutsch-Jozsa روی یک رایانه یا شبیه‌ساز کوانتومی به‌صورت زیر پیاده‌سازی می‌شود: 

\begin{itemize}
	\item \textbf{مقداردهی اولیه:}
	با \(n \) کیوبیت در حالت \(\lvert 0 \rangle \) و یک کیوبیت اضافی (کیوبیت جواب) در حالت \(\lvert 1 \rangle \) شروع می‌کنیم. سپس کیوبیت جواب با استفاده از گیت Hadamard به حالت \(\lvert - \rangle \) تبدیل می‌کنیم.
	\item \textbf{برهم‌نهی:}
	گیت Hadamard را به اولین \(n \) کیوبیت اعمال کرده تا یک برهم‌نهی از تمام حالات ورودی ممکن ایجاد شود. حالت سامانه به یک برهم‌نهی یکنواخت از تمام \(2^n \) حالت ورودی ممکن تبدیل می‌شود.
	\item \textbf{پرسش از \lr{Oracle}:}
	\lr{Oracle} کوانتومی \(U_f \) را اعمال کرده که تابع \(f \) را درون خودش حفظ می‌کند با این تفاوت که فاز دامنهٔ مربوط به ورودی‌هایی که در آن \(f(x) = 1 \) است را تغییر می‌دهد.
	\item \textbf{تداخل:}
	دوباره گیت Hadamard را به تمام \(n \) کیوبیت اعمال می‌کنیم. این مرحله باعث تداخل سازنده بین دامنه‌ها می‌شود و دامنه جواب صحیح را تقویت می‌کند.
	\item \textbf{اندازه‌گیری:}
	اولین \(n \) کیوبیت را اندازه‌گیری می‌کنیم. اگر نتیجه اندازه‌گیری
	\(\lvert 0 \rangle^{\otimes n} \)
	 باشد، تابع ثابت است؛ در غیر این صورت، تابع متعادل است.
\end{itemize}

\subsubsection{مدار کوانتومی}
در زیر نمودار مدار کوانتومی برای ورودی با \(n \) کیوبیت رسم شده است.
\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\[
	\Qcircuit @C=1.7em @R=1em {
		& \lstick{\ket{-}} & \qw & \qw & \multigate{4}{U_f} & \qw & \qw \\
		& \lstick{\ket{0}} & \gate{H} & \qw & \ghost{U_f} & \gate{H} & \meter \\
		& \lstick{\ket{0}} & \gate{H} & \qw & \ghost{U_f} & \gate{H} & \meter \\
		& \lstick{\vdots} & \vdots & & & \vdots & \vdots \\
		& \lstick{\ket{0}} & \gate{H} & \qw & \ghost{U_f} & \gate{H} & \meter
		\inputgroupv{2}{5}{1.5em}{3em}{n}\\
	}
	\]
	\caption{
		نمودار مدار کوانتومی الگوریتم
		\lr{Deutsch-Jozsa}
	}
	\label{fig:3.1}
\end{figure}

\subsubsection{چالش‌ها}
چالشی که در پیاده‌سازی تمامی الگوریتم‌ها مشترک بوده است، پیاده‌سازی آن‌ها برای شبیه‌سازهای مختلف است. برای پیاده‌سازی هر الگوریتم در یک شبیه‌ساز، باید چارچوب‌های آن شبیه‌ساز رعایت شود. به‌عنوان‌مثال، با این که چارچوب پیاده‌سازی در سامانهٔ Qiskit با سامانهٔ Cirq متفاوت است اما باید سعی شود که پیاده‌سازی‌ها تا جایی که ممکن است برای رعایت انصاف، مشابه هم باشد. رعایت این نکته‌ کاری زمان‌بر و مشکل است که عمدهٔ زمان پژوهش را به خودش اختصاص داده است. در کل، به طور خاص برای این الگوریتم، چالشی وجود نداشت.

\subsection{Bernstein-Vazirani}
الگوریتم
\lr{Bernstein-Vazirani}
یک الگوریتم کوانتومی است که مسئلهٔ یافتن یک‌رشتهٔ مخفی کدگذاری شده در یک تابع را به طور کارآمد حل می‌کند. با داشتن تابع \(f(x) \) که حاصل‌ضرب نقطه‌ای یک‌رشته دودویی ناشناخته \(s \) و ورودی \(x \) را خروجی می‌دهد، هدف یافتن رشته \(s \) است. به‌عبارت‌دیگر می‌توان نوشت، \(f(x) = s \cdot x\) که ما به دنبال یافتن \(s \) هستیم. درحالی‌که یک روش کلاسیک به \(n \) بار ورودی‌دادن به Oracle برای یک‌رشته به طول \(n \) نیاز دارد، الگوریتم
\lr{Bernstein-Vazirani}
می‌تواند رشته \(s \) را تنها با یک‌بار ورودی‌دادن، پیدا کند که این یک کاهش پیچیدگی چندجمله‌ای را در پی دارد.

\subsubsection{پیاده‌سازی}
الگوریتم
\lr{Bernstein-Vazirani}
روندی مشابه الگوریتم
\lr{Deutsch-Jozsa}
را دنبال می‌کند:

\begin{itemize}
	\item \textbf{مقداردهی اولیه:}
	 با \( n \) کیوبیت در حالت \(\ket{0} \) و یک کیوبیت اضافی (کیوبیت جواب) در حالت \( \lvert 1 \rangle \) شروع می‌کنیم. سپس کیوبیت جواب با استفاده از گیت Hadamard به حالت \( \lvert - \rangle \) تبدیل می‌کنیم.
	\item \textbf{برهم‌نهی:}
	 گیت Hadamard را به اولین \( n \) کیوبیت اعمال می‌کنیم تا یک برهم‌نهی از تمام حالات ورودی ممکن ایجاد شود. این عمل هر کیوبیت را به حالتی تبدیل می‌کند که برهم‌نهی 0 و 1 را نشان می‌دهد.
	\item \textbf{پرسش از اوراکل:}
	 \lr{Oracle} \( U_f \) را اعمال می‌کنیم که تابع \( f(x) = s \cdot x \) را محاسبه کرده و نتیجه را در کیوبیت جواب کدگذاری می‌کند. این مرحله عملاً حالات مربوط به مقادیر صحیح \( s \) را نشانه‌گذاری می‌کند تا یافتن آن‌ها در زمان اندازه‌گیری آسان شود.
	\item \textbf{تداخل:}
	 دوباره گیت Hadamard را به تمام \( n \) کیوبیت اعمال می‌کنیم. این باعث تداخل سازنده و مخرب بین حالات کوانتومی می‌شود و سامانه را در حالتی باقی می‌گذارد که مستقیماً رشتهٔ مخفی \( s \) را بعد از اندازه‌گیری نشان دهد.
	\item \textbf{اندازه‌گیری:}
	 اولین \( n \) کیوبیت را اندازه‌گیری می‌کنیم که نتیجه، رشته‌ٔ مخفی \( s \) خواهد بود.
\end{itemize}
\subsubsection{مدار کوانتومی}
\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\[
	\Qcircuit @C=1.7em @R=1em {
		& \lstick{\ket{-}} & \qw & \qw & \multigate{4}{U_f} & \qw & \qw \\
		& \lstick{\ket{0}} & \gate{H} & \qw & \ghost{U_f} & \gate{H} & \meter \\
		& \lstick{\ket{0}} & \gate{H} & \qw & \ghost{U_f} & \gate{H} & \meter \\
		& \lstick{\vdots} & \vdots & & & \vdots & \vdots \\
		& \lstick{\ket{0}} & \gate{H} & \qw & \ghost{U_f} & \gate{H} & \meter
		\inputgroupv{2}{5}{1.5em}{3em}{n}\\
	}
	\]
	\caption{
		نمودار مدار کوانتومی الگوریتم
		\lr{Bernstein-Vazirani}
	}
	\label{fig:3.2}
\end{figure}

\subsubsection{چالش‌ها}
چالش‌های مربوط به پیاده‌سازی این الگوریتم هم مانند
\lr{Deutsch-Jozsa}
است و تفاوت زیادی بین آن‌ها وجود ندارد.
\subsection{Simon}
الگوریتم Simon یک الگوریتم کوانتومی است که مسئله‌ای خاص به نام مسئلهٔ Simon را به طور نمایی سریع‌تر از هر الگوریتم کلاسیک شناخته‌شده‌ای، حل می‌کند. این مسئله شامل یافتن یک‌رشتهٔ مخفی \(s \) است به‌طوری‌که برای یک تابع داده‌شده \(f \)، \(f(x) = f(y) \) اگر و تنها اگر \(x \oplus y = s \) باشد. این الگوریتم مهم است؛ زیرا اولین الگوریتمی بود که کاهش پیچیدگی نمایی الگوریتم‌های کوانتومی نسبت به الگوریتم‌های کلاسیک را نشان داد و قدرت بالقوه محاسبات کوانتومی را برجسته کرد.

\subsubsection{پیاده‌سازی}
پیاده‌سازی الگوریتم Simon شامل مراحل زیر است:
\begin{itemize}
	\item \textbf{مقداردهی اولیه:}
در ابتدا \( n \) کیوبیت را در حالت \( \lvert 0 \rangle \) (نماینده‌ٔ Register ورودی) و به همین صورت، \( n \) کیوبیت دیگر را در حالت \( \lvert 0 \rangle \) (نماینده Register خروجی) مقداردهی اولیه می‌کنیم.
	\item \textbf{برهم‌نهی:}
	 گیت Hadamard را به کیوبیت‌های ورودی اعمال می‌کنیم تا یک برهم‌نهی از تمام ورودی‌های ممکن ایجاد شود.
	\item \textbf{پرسش از \lr{Oracle}:}
	 \lr{Oracle} \( U_f \) را اعمال می‌کنیم که \( \lvert x \rangle \lvert y \rangle \) را به \( \lvert x \rangle \lvert y \oplus f(x) \rangle \) نگاشت می‌کند. \lr{Oracle} به‌گونه‌ای طراحی شده که \( f(x) = f(y) \) شود، زمانی که \( x \oplus y = s \) باشد.
	\item \textbf{تداخل:}
	 دوباره گیت Hadamard را به کیوبیت‌های ورودی اعمال می‌کنیم. این مرحله از تداخل کوانتومی استفاده می‌کند تا اطلاعات موردنظر در مورد رشته‌ٔ مخفی \( s \) را استخراج کند.
	\item \textbf{اندازه‌گیری:}
کیوبیت‌های ورودی را اندازه‌گیری می‌کنیم. نتایج اندازه‌گیری رشته‌های بیتی \( z \) را می‌دهند که \( s \cdot z = 0 \) (در مبنای ۲) را برقرار می‌کنند. با تکرار الگوریتم با پیچیدگی \( O(n) \) بار، اطلاعات کافی برای تعیین \( s \) جمع‌آوری می‌شود.
\end{itemize}
\subsubsection{مدار کوانتومی}
در ادامه، شکل \ref{fig:3.3} نمودار مدار کوانتومی برای ورودی با \(n \) کیوبیت را نشان می‌دهد.
\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\[
	\Qcircuit @C=1.7em @R=1em {
		& \lstick{\ket{0}} & \qw & \qw & \multigate{7}{U_f} & \qw & \meter \\
		& \lstick{\ket{0}} & \qw & \qw & \ghost{U_f} & \qw & \meter \\
		& \lstick{\vdots} & \vdots & & & \vdots & \vdots \\
		& \lstick{\ket{0}} & \qw & \qw & \ghost{U_f} & \qw & \meter \\
		& \lstick{\ket{0}} & \gate{H} & \qw & \ghost{U_f} & \gate{H} & \meter \\
		& \lstick{\ket{0}} & \gate{H} & \qw & \ghost{U_f} & \gate{H} & \meter \\
		& \lstick{\vdots} & \vdots & & & \vdots & \vdots \\
		& \lstick{\ket{0}} & \gate{H} & \qw & \ghost{U_f} & \gate{H} & \meter
		\inputgroupv{1}{4}{1.5em}{3em}{n}
		\inputgroupv{5}{8}{1.5em}{3em}{n} \\
	}
	\]
	\caption{
		نمودار مدار کوانتومی الگوریتم
		\lr{Simon}
	}
	\label{fig:3.3}
\end{figure}

\subsubsection{چالش‌ها}
چالش‌های پیاده‌سازی این الگوریتم هم تا حد زیادی مانند دیگر الگوریتم‌ها بوده است. به‌علاوه، چون ماهیت این الگوریتم تکرار اجرای آن و جمع‌آوری خروجی‌های هر اجرا است، همان‌طور که در قبل هم اشاره شد، بعضی شبیه‌سازها نظیر DDSIM قابلیت پیاده‌سازی آن به صورتی که قابل‌مقایسه با دیگر شبیه‌سازها باشد را نداشتند.
\subsection{\lr{Quantum Fourier Transform (QFT)}}
\lr{Quantum Fourier Transform (QFT)}
معادل کوانتومی تبدیل فوریهٔ گسسته کلاسیک است. این تبدیل یک جزء اساسی در بسیاری از الگوریتم‌های کوانتومی، از جمله الگوریتم Shor برای تجزیه اعداد بزرگ است. QFT یک حالت کوانتومی را به حوزهٔ بَسامد آن تبدیل می‌کند، همان‌طور که تبدیل فوریهٔ کلاسیک برای یک سیگنال انجام می‌دهد. برخلاف معادل کلاسیک خود که برای مجموعه داده‌ای به‌اندازه \(N \) به \(O(N \log N) \) عملیات نیاز دارد، QFT را می‌توان با استفاده از گیت‌های کوانتومی برای پیاده‌سازی راه‌حل با پیچیدگی \(O(\log^2 N) \) پیاده‌سازی کرد که یک افزایش سرعت نمایی در پیچیدگی مدار ارائه می‌دهد.
\subsubsection{پیاده‌سازی}
الگوریتم QFT روی یک رایانه‌ٔ کوانتومی با استفاده از مراحل زیر پیاده‌سازی می‌شود:

\begin{itemize}
	\item \textbf{مقداردهی اولیه:}
یک Register کوانتومی در حالت پایه \( \lvert j \rangle \) را مقداردهی اولیه می‌کنیم.
	\item \textbf{برهم‌نهی:}
یک گیت Hadamard را به کیوبیت با بیش‌ترین ارزش (منظور سمت چپ‌ترین کیوبیت در نوشتار دودویی است) اعمال می‌کنیم تا یک برهم‌نهی از حالات ایجاد شود.
	\item \textbf{چرخش فاز کنترل‌شده:}
یک‌رشته گیت‌های چرخش فاز کنترل‌شده \( R_k \) را از اولین کیوبیت به هر کیوبیت بعدی اعمال می‌کنیم، جایی که \( R_k \) یک چرخش با زاویه‌ای وابسته به موقعیت کیوبیت در Register است. این وابستگی را می‌توان با ورودی دیگر کنترلی گیت‌ها، اعمال کرد.
	\item \textbf{معکوس ‌کردن:}
برای تصحیح ترتیب کیوبیت‌ها پس از اعمال \lr{QFT}، موقعیت کیوبیت‌ها را معکوس می‌کنیم.
\end{itemize}

\subsubsection{مدار کوانتومی}
شکل \ref{fig:3.4} نمودار مدار کوانتومی برای ورودی با \(n \) کیوبیت را نشان می‌دهد.
\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
\[
\Qcircuit @C=0.37em @R=0.8em {
	\lstick{j_0} &	\qw &	\qw &	\qw &	\push{\dots} &	\qw &	\qw &	\ctrl{4} &	\qw &	\qw &	\push{\dots} &	\qw &	\qw &	\ctrl{3} &	\qw &	\push{\dots} &	\qw &	\qw &	\ctrl{1} &	\gate{H} &	\qw &	\qswap &	\qw &	\qw &	\qw &	\rstick{k_0} \\
	\lstick{j_1} &	\qw &	\qw &	\qw &	\push{\dots} &	\qw &	\ctrl{3} &	\qw &	\qw &	\qw &	\push{\dots} &	\qw &	\ctrl{2} &	\qw&	\qw &	\push{\dots} &	\qw &	\gate{H}  &	\gate{R_{2}} &	\qw &	\qw &	\qwx &	\qw &	\qswap&	\qw &	\rstick{k_1} \\
	\lstick{\vdots} &	&	&	&	&	&	&	&	&	&	&	&	&	&	&	&	&	&	&	&	&	\qwx &	&	\qwx &	&	\rstick{\vdots} \\
	\lstick{j_{n-2}} &	\qw &	\ctrl{1} &	\qw &	\push{\dots} &	\qw &	\qw &	\qw &	\gate{H} &	\qw &	\push{\dots} &	\qw &	\gate{R_{n-2}} &	\gate{R_{n-1}} &	\qw &	\push{\dots} &	\qw &	\qw &	\qw &	\qw &	\qw &	\qwx &	\qw &	\qswap \qwx&	\qw &	\rstick{k_{n-2}} \\
	\lstick{j_{n-1}} &	\gate{H} &	\gate{R_2} &	\qw&	\push{\dots} &	\qw&	\gate{R_{n-1}} &	\gate{R_{n}} &	\qw &	\qw&	\push{\dots} &	\qw&	\qw &	\qw &	\qw&	\push{\dots} &	\qw&	\qw &	\qw &	\qw &	\qw&	\qswap \qwx &	\qw&	\qw &	\qw&	\rstick{k_{n-1}} \\
}
\]
	\caption{
		نمودار مدار کوانتومی الگوریتم
		\lr{QFT}
	}
	\label{fig:3.4}
\end{figure}

\subsubsection{چالش‌ها}
همان چالش مشابه با دیگر الگوریتم‌ها یعنی پیاده‌سازی یکسان در شبیه‌سازها مختلف است. تفاوت دیگر این الگوریتم، نبود مرحلهٔ اندازه‌گیری است که از ماهیت آن نشئت می‌گیرد در نتیجه چالش عمده، بررسی درستی عملکرد این الگوریتم است.
\subsection{Grover}
الگوریتم Grover یک الگوریتم جستجوی کوانتومی است که کاهش پیچیدگی درجهٔ دوم نسبت به الگوریتم‌های جستجوی کلاسیک را فراهم می‌کند. این الگوریتم برای جستجو در یک پایگاه‌داده نامرتب یا حل مسئلهٔ یافتن یک ورودی برای تابعی که خروجی خاصی تولید می‌کند، استفاده می‌شود. درحالی‌که الگوریتم‌های کلاسیک به \(O(N) \) بار ورودی‌دادن برای یافتن عنصر موردنظر در یک فهرست از \(N \) شئ نیاز دارند، الگوریتم Grover می‌تواند این کار را با \(O(\sqrt{N}) \) انجام دهد که نشان‌دهندهٔ توانایی محاسبات کوانتومی برای حل برخی مسائل به طور کارآمدتر نسبت به محاسبات کلاسیک است.

\subsubsection{پیاده‌سازی}
الگوریتم Grover شامل مراحل کلیدی زیر است: 
\begin{itemize}
	\item \textbf{مقداردهی اولیه:}
	الگوریتم را با مقداردهی اولیه \(n \) کیوبیت در حالت \(\lvert 0 \rangle \) شروع می‌کنیم.
	\item \textbf{برهم‌نهی:}
سپس گیت‌های Hadamard را اعمال می‌کنیم تا همهٔ کیوبیت‌ها در یک برهم‌نهی از تمام حالات ممکن قرار بگیرند.
	\item \textbf{پرسش از \lr{Oracle}:}
\lr{Oracle}
کوانتومی را اعمال می‌کنیم تا راه‌حل صحیح را با معرفی یک تغییر فاز \(\pi \) در دامنه حالت هدف علامت‌گذاری کند.
	\item \textbf{تقویت دامنه:}
	الگوریتم با اعمال یک‌رشته بازتاب\LTRfootnote{Reflection}ها، احتمال دامنهٔ حالت صحیح را تقویت می‌کند. بازتاب اول روی میانگین اندازهٔ تمام حالات است و سپس بازتاب دیگر روی حالت اولیه اعمال می‌شود.
	\item \textbf{تکرار:}
	مراحل ۲ و ۳ به تعداد \(O(\sqrt{N}) \) بار تکرار می‌شوند تا احتمال اندازه‌گیری حالت صحیح به حداکثر برسد.
	\item \textbf{اندازه‌گیری:}
	در نهایت، کیوبیت‌ها اندازه‌گیری می‌شوند و نتیجه با احتمال بالاتر پاسخ ما خواهد بود.
\end{itemize}
\subsubsection{مدار کوانتومی}
نمودار مدار کوانتومی الگوریتم Grover در شکل \ref{fig:3.4} رسم شده است.
\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\[
	\Qcircuit @C=1em @R=1em {
	&	& \lstick{\ket{-}} &	\multigate{5}{U_f}     &	\qw                 &	\multigate{5}{U_f}     &	\qw                 &	\qw &	\multigate{5}{U_f}     &	\qw                 &	\qw \\
	&	& \lstick{\ket{+}} &	\ghost{U_f}            &	\multigate{4}{R_s}  &	\ghost{U_f}            &	\multigate{4}{R_s}  &	\qw &	\ghost{U_f}            &	\multigate{4}{R_s}  &	\meter \\
	&	& \lstick{\ket{+}} &	\ghost{U_f}            &	\ghost{R_s}         &	\ghost{U_f}            &	\ghost{R_s}         &	\qw &	\ghost{U_f}            &	\ghost{R_s}         &	\meter \\
	&	& \lstick{\vdots}  &	          &	\nghost{R_s}       &	          &	\nghost{R_s}       &	\push{\cdots}	          &	\nghost{R_s}       &	& \vdots \\
	&	& \lstick{\ket{+}} &	\ghost{U_f}            &	\ghost{R_s}         &	\ghost{U_f}            &	\ghost{R_s}         &	\qw &	\ghost{U_f}            &	\ghost{R_s}         &	\meter \\
	&	& \lstick{\ket{+}} &	\ghost{U_f}            &	\ghost{R_s}         &	\ghost{U_f}            &	\ghost{R_s}         &	\qw &	\ghost{U_f}            &	\ghost{R_s}         &	\meter
	\inputgroupv{2}{6}{1em}{4.5em}{n} \\
	}
	\]
	\caption{
		نمودار مدار کوانتومی الگوریتم \lr{Grover}
	}
	\label{fig:3.5}
\end{figure}


\subsubsection{چالش‌ها}
علاوه بر چالش‌های مطرح شده مثل دیگر الگوریتم‌ها، پیاده‌سازی این الگوریتم مانند الگوریتم Simon، نیاز به ذخیرهٔ خروجی هر بار اجرای الگوریتم را دارد که با بعضی شبیه‌سازهایی که توسعهٔ آن‌ها تکمیل نشده، به چالش برخورد کردیم.
\subsection{Shor}
الگوریتم Shor یک الگوریتم کوانتومی است که برای تجزیهٔ اعداد صحیح، به‌ویژه تجزیهٔ یک عدد صحیح بزرگ مانند \(N \) به عوامل اول آن، طراحی شده است. این یک عملیاتی است که برای رایانه‌های کلاسیک محاسباتی دشوار است، به‌ویژه با بزرگ‌شدن \(N \) که آن را به پایه‌ای برای سامانه‌های رمزنگاری رایج مانند RSA تبدیل کرده است. الگوریتم Shor که توسط \lr{Peter Shor} در سال ۱۹۹۴ معرفی شد، می‌تواند \(N \) را به طور کارآمد با استفاده از محاسبات کوانتومی تجزیه کند، رمزنگاری RSA را شکسته و توانایی رایانه‌های کوانتومی برای حل این دسته از مسائل را به طور نمایی سریع‌تر از رایانه‌های کلاسیک نشان دهد.

\subsubsection{پیاده‌سازی}
الگوریتم Shor را می‌توان به مراحل زیر تقسیم کرد: 
\begin{itemize}
	\item \textbf{انتخاب یک عدد تصادفی:}
	یک عدد صحیح تصادفی \(a \) را انتخاب می‌کنیم به‌طوری‌که نامعادلهٔ \(1 < a < N \) برقرار باشد. بزرگ‌ترین مقسومٌ‌علیه مشترک (ب.م.م) \(a \) و \(N \) را با استفاده از الگوریتم اقلیدسی محاسبه می‌کنیم. اگر ب.م.م بیشتر از ۱ باشد، پس این یک عامل غیربدیهی \(N \) است و الگوریتم متوقف می‌شود.
	\item \textbf{یافتن دوره تناوب:}
	اگر بزرگ‌ترین مقسومٌ‌علیه مشترک برابر با ۱ باشد، مرحلهٔ بعدی یافتن دورهٔ تناوب \(r \) تابع \(f(x) = a^x \mod N \) است. دورهٔ \(r \) کوچک‌ترین عدد صحیح است که معادلهٔ \(a^r \equiv 1 \mod N \) در رابطه با آن برقرار است. یافتن این دوره تناوب برای رایانه‌های کلاسیک پیچیده است، اما می‌توان آن را به طور کارآمد با استفاده از یک رایانهٔ کوانتومی و تبدیل فوریه کوانتومی انجام داد.
	\item \textbf{تعیین عوامل:}
	هنگامی که دورهٔ \(r \) پیدا شد، اگر \(r \) زوج بود، مقدار \(a^{r/2} \mod N \) را محاسبه می‌کنیم. اگر \(a^{r/2} \not\equiv -1 \mod N \) بود، عوامل \(N \) توسط بزرگ‌ترین مقسومٌ‌علیه‌های مشترک \(\text{gcd} (a^{r/2} - 1, N) \) و \(\text{gcd} (a^{r/2} + 1, N) \) مشخص می‌شوند. اگر این مقادیر، عوامل غیربدیهی تولید نکنند، این فرایند با یک \(a \) دیگر تکرار می‌شود.
	
	قسمت کوانتومی الگوریتم Shor شامل یافتن دوره \(r \) با استفاده از هم‌زمانی کوانتومی و تبدیل فوریه کوانتومی است که اجازه می‌دهد دوره \(r \) به طور کارآمد تعیین شود.
\end{itemize}

\subsubsection{مدار کوانتومی}
مدار کوانتومی الگوریتم Shor در شکل \ref{fig:3.6} رسم شده است.

\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\[
	\Qcircuit @C=0.7em @R=1em {
		\lstick{\ket{0}} &	 \qw &	 \gate{H} &	 \qw &	 \qw &	 \qw &	 \qw &	 \push{\cdots} &	 \qw &	 \ctrl{4} &	 \qw &	 \multigate{3}{\text{QFT}_{2n}^{-1}} &	 \meter \\
		\lstick{\vdots} &	 &	\vdots &	 &	 &	 &	 &	 &	 &	 &	 &	 &	 \vdots \\
		\lstick{\ket{0}} &	 \qw &	 \gate{H} &	 \qw &	 \qw &	 \ctrl{2} &	 \qw &	 \push{\cdots} &	 \qw &	 \qw &	 \qw &	 \ghost{\text{QFT}_{2n}^{-1}} &	 \meter \\
		\lstick{\ket{0}} &	 \qw &	 \gate{H} &	 \qw &	 \ctrl{1} &	 \qw &	 \qw &	 \push{\cdots} &	 \qw &	 \qw &	 \qw &	 \ghost{\text{QFT}_{2n}^{-1}} &	 \meter \\
		\lstick{\ket{1}} &	 \qw &	\qw /^{n}&	 \qw &	 \gate{U_{a^{2^0}}} &	 \gate{U_{a^{2^1}}} &	 \qw &	 \push{\cdots} &	 \qw &	 \gate{U_{a^{2^{2n-1}}}} &	 \qw &	 \qw &	 \qw \\
	}
	\]
	\caption{
		نمودار مدار کوانتومی الگوریتم \lr{Shor}
	}
	\label{fig:3.6}
\end{figure}

\subsubsection{چالش‌ها}
علاوه بر چالش‌های ذکر شده، پیاده‌سازی این الگوریتم، بسیار زمان‌بر و مشکل بود. جدا از فهم خود الگوریتم، منطبق کردن خواسته‌های آن و پیاده‌سازی آن در شبیه‌سازهای مختلف، زمان زیادی از این پژوهش را به خود اختصاص داد.

\section{نرم‌افزار محک پیاده‌سازی‌شده}
در روند محک، عملیات‌هایی وجود دارند که برای همهٔ شبیه‌سازها تکراری هستند. برای مثال، رسم نمودار، تغییرات جزئی در نحوهٔ ورودی‌های اصلی، نحوه‌ی اندازه‌گیری معیارهای محک و غیره. به همین منظور در اواسط طول دورهٔ پژوهش، تصمیم بر آن شد که یک ابزار نرم‌افزاری برای تسهیل در این روند توسعه داده شود که به روند پژوهش کمک کند. این ابزار در مخزن GitHub\LTRfootnote{\url{https://github.com/ahmadrv/QSB}} به‌صورت عمومی قابل‌دسترس است. با این که این ابزار تمامی پیاده‌سازی‌ها و روند پژوهش را شامل می‌شود؛ اما تلاش بر آن است که در آینده به یک محصول نرم‌افزاری پیشرفته برای محک شبیه‌سازهای کوانتومی تبدیل شود به‌گونه‌ای که استفاده از آن مستقل از نرم‌افزار شبیه‌ساز و سخت‌افزار مربوط به آن باشد.

\section{سخت‌افزار محک}
همان‌طور که در قسمت پژوهش‌های پیشین هم گفته شد، یکی از وجه تمایزهای  پژوهش ما با مشابه‌ترین پژوهش مربوطه، این است که فرض بر آن است، کاربر شبیه‌سازها از سخت‌افزار بسیار پیچیده و بزرگ استفاده نمی‌کند، بلکه از رایانهٔ شخصی معمول بهره می‌برد. به همین منظور رایانهٔ استفاده شده در  پژوهش ما برای انجام آزمایش‌ها به شرح زیر است:
\begin{LTR}
	\begin{itemize}
		\item \lr{\textbf{OS:} Linux, Ubuntu 22.04 LTS, 5.15.0-119-generic Kernel Version}
		\item \lr{\textbf{CPU:} Intel(R) Core(TM) i7-3770 CPU @ 3.40GHz with 8 Cores}
		\item \lr{\textbf{RAM:} DDR3 with 16 Gigabyte Storage}
	\end{itemize}
\end{LTR}
